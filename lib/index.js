var f=Object.defineProperty;var O=Object.getOwnPropertyDescriptor;var q=Object.getOwnPropertyNames;var H=Object.prototype.hasOwnProperty;var x=(e,t)=>{for(var n in t)f(e,n,{get:t[n],enumerable:!0})},D=(e,t,n,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of q(t))!H.call(e,r)&&r!==n&&f(e,r,{get:()=>t[r],enumerable:!(o=O(t,r))||o.enumerable});return e};var I=e=>D(f({},"__esModule",{value:!0}),e);var U={};x(U,{activate:()=>J});module.exports=I(U);var d=require("coc.nvim");var j=require("coc.nvim");var v=require("coc.nvim"),p=[{scheme:"file",language:"clojure"},{scheme:"jar",language:"clojure"},{scheme:"zipfile",language:"clojure"}],m;function k(){var l,u;let e=v.workspace.getConfiguration("clojure"),t=e.inspect("keymaps"),n=e.inspect("executable"),o=e.inspect("enable"),r=e.inspect("executableArgs"),c=e.inspect("initializationOptions"),s=e.inspect("startupMessage");m={keymaps:{enable:e.get("keymaps.enable",(l=t.defaultValue)==null?void 0:l.enable),shortcut:e.get("keymaps.shortcut",(u=t.defaultValue)==null?void 0:u.shortcut)},enable:e.get("enable",o.defaultValue),executable:e.get("executable",n.defaultValue),executableArgs:e.get("executableArgs",r.defaultValue),initializationOptions:e.get("initialization-options",c.defaultValue),startupMessage:e.get("startup-message",s.defaultValue)}}function P(){let e={command:m.executable,args:m.executableArgs},t={run:e,debug:e},n={disabledFeatures:["signatureHelp"],documentSelector:p,initializationOptions:m.initializationOptions};return new j.LanguageClient("clojure","Clojure Language Client",t,n)}var i=require("coc.nvim");var h={};x(h,{commands:()=>M,default:()=>z});var M=[{command:"add-import-to-namespace",description:"Add specific require form to current namespace declaration",prompt:"Library name?",shortcut:"ai"},{command:"add-missing-import",description:"Add Java import for symbol under cursor to current namespace declaration"},{command:"add-missing-libspec",description:"Add require form for symbol under cursor to current namespace declaration",shortcut:"am"},{command:"add-require-suggestion",description:"Add suggested require to ns form",shortcut:"as"},{aliases:["change-coll"],choices:["list","vector","map","set"],command:"change-collection",description:"Choose new type of collection",prompt:"New coll type"},{command:"clean-ns",description:"Sort and remove unused required libraries in namespace declaration",shortcut:"cn"},{command:"create-function",description:"Create a function from the current form",shortcut:"fe"},{command:"create-test",description:"Creates a test somewhere, who knows",shortcut:"ct"},{command:"cursor-info",description:"Show debugging information for the symbol at cursor"},{command:"cycle-coll",description:"Cycle the kind of collection: list -> map -> vector -> set -> list",shortcut:"cc"},{command:"cycle-privacy",description:"Cycle the privacy of current function definition",shortcut:"cp"},{command:"demote-fn",description:"Demote fn to #()",shortcut:"dm"},{command:"docs",description:"Read the docs for a given symbol (in given namespace)"},{aliases:["move-coll-entry-up"],command:"drag-backward",description:"Move coll entry backwards in collection (will move map entries)",shortcut:"db"},{aliases:["move-coll-entry-down"],command:"drag-forward",description:"Move coll entry forwards in collection (will move map entries)",shortcut:"df"},{command:"expand-let",description:"Move current let form up a level",shortcut:"el"},{command:"extract-function",description:"Move current form into new top-level function",prompt:"Function name?",shortcut:"ef"},{command:"inline-symbol",description:"Replace all instances of symbol with symbol definition",shortcut:"is"},{command:"introduce-let",description:"Move current form to let-bound variable",prompt:"Bind to?",shortcut:"il"},{command:"move-coll-entry-down",description:"Move the current element (or pair) down within the collection"},{command:"move-coll-entry-up",description:"Move the current element (or pair) up within the collection"},{command:"move-form",description:"Move form under cursor to specified file",prompt:"Which file?",shortcut:"mf"},{command:"move-to-let",description:"Move current form into surrounding let block",prompt:"Bind to?",shortcut:"ml"},{command:"promote-fn",description:"Promote #() to fn, or fn to defn",shortcut:"pf"},{command:"resolve-macro-as",description:"Add entry to .clj-kondo/config.edn to resolve macro as another macro",shortcut:"ma"},{command:"server-info",description:"Show server configuration information"},{command:"sort-map",description:"Sort entries within current map",shortcut:"sm"},{command:"suppress-diagnostic",description:"Add a :clj-kondo/ignore to suppress linting current line",prompt:"Lint to ignore?"},{command:"thread-first",description:"Replace current form with thread-first expession",shortcut:"th"},{command:"thread-first-all",description:"Replace current and all nested forms with thread-first form",shortcut:"tf"},{command:"thread-last",description:"Replace current form with thread-last expession",shortcut:"tt"},{command:"thread-last-all",description:"Replace current and all nested forms with thread-last form",shortcut:"tl"},{command:"unwind-all",description:"Replace entire current threaded form with nested form",shortcut:"ua"},{command:"unwind-thread",description:"Replace first two forms in current threaded form with nested form",shortcut:"uw"}],z={commands:M};var a;function S(e){a=e.logger}async function C(e,t=""){return e?(await i.window.requestInput(e,t)).trim():void 0}async function V(e){let t=await C("Var name?"),n=await C("Namespace?","clojure.core");if(t&&n){let o=await e.sendRequest("clojure/clojuredocs/raw",{symName:t,symNs:n}).catch(r=>{i.window.showErrorMessage(r)});o&&await i.window.showDialog({title:`${o.ns}/${o.name}`,content:o.doc})}}async function R(){let{line:e,character:t}=await i.window.getCursorPosition();return[(await i.workspace.document).uri,e,t]}var B=[{command:"docs",fn:V},{command:"cursor-info",fn:async e=>{let[t,n,o]=await R();return e.sendRequest("clojure/cursorInfo/log",{textDocument:{uri:t},position:{line:n,character:o}}).catch(r=>{i.window.showErrorMessage(r)})}},{command:"server-info",fn:async e=>e.sendRequest("clojure/serverInfo/log").catch(t=>{i.window.showErrorMessage(t)})}],$=(()=>{let{commands:e}=h,t=new Map;return e.concat(B).forEach(n=>{let o=n.command;t.has(o)||t.set(o,{command:o});for(let[r,c]of Object.entries(n)){let s=t.get(o);s&&!s[r]&&(s[r]=c)}}),[...t.values()]})();async function w(e,{command:t},n=[]){let o=await R();return e.sendRequest("workspace/executeCommand",{command:t,arguments:o.concat(n)}).catch(r=>{i.window.showErrorMessage(r)})}async function K(e,t){if(!e||!t)return;let n=await i.window.showMenuPicker(t,{title:e});if(n!==-1)return t[n]}async function N(e,t){let{title:n,choices:o}=t,r=await K(n,o),c=[];return r&&c.push(r),w(e,t,c)}async function T(e,t){let{title:n}=t,o=await C(n);if(o)return w(e,t,[o])}function F(e,t,n){let{command:o,fn:r,title:c,choices:s,aliases:l}=n,u=`lsp-clojure-${o}`,y=async()=>{if(s&&!i.workspace.env.dialog){a.info(`Workspace doesn't allow dialogs, cancelling command ${u}`);return}else{if(r)return a.debug(`Executing 'fn' command ${u}`),r(t);s?(a.debug(`Executing 'choices' command ${u}`),await N(t,n)):c?(a.debug(`Executing 'prompt' command ${u}`),await T(t,n)):(a.debug(`Executing 'position' command ${u}`),await w(t,n))}};a.debug(`Registering command ${u}`),e.subscriptions.push(i.commands.registerCommand(u,y)),l&&l.forEach(A=>{let b=`lsp-clojure-${A}`;a.debug(`Registering command ${b} as alias of ${u}`),e.subscriptions.push(i.commands.registerCommand(b,y))})}function W(e,t){let{command:n,shortcut:o}=t,r=`lsp-clojure-${n}`,{keymaps:c}=m,s=`${c.shortcut}${o}`;try{a.debug(`Creating keymap '${s}' for command '${r}'`),i.workspace.nvim.command(`nnoremap <silent> ${s} :call CocActionAsync('runCommand', '${r}')<CR>`,!0),e.subscriptions.push(i.Disposable.create(()=>{i.workspace.nvim.command(`nunmap ${s}`,!0)}))}catch(l){a.error(`Can't create keymapping ${s} for command ${n}`,l)}}function E(e,t){for(let n of $)F(e,t,n);if(m.keymaps.enable)for(let n of $.filter(o=>o.shortcut))W(e,n)}var g=class{constructor(t){this.client=t}async provideSignatureHelp(t,n,o,r){return this.client.sendRequest("textDocument/signatureHelp",{textDocument:{uri:t.uri},position:n,context:r},o).catch(c=>this.client.handleFailedRequest({method:"textDocument/signatureHelp"},o,c,null))}};async function J(e){if(S(e),a.info("Starting up coc-clojure"),k(),!m.enable)return;let t=null;m.startupMessage&&(a.info("Showing statusItem"),t=d.window.createStatusBarItem(void 0,{progress:!0}),t.text="Loading clojure-lsp",t.show()),a.info("Creating client");let n=P();e.subscriptions.push(d.services.registLanguageClient(n)),e.subscriptions.push(d.languages.registerSignatureHelpProvider(p,new g(n),["("," "])),E(e,n),await n.onReady(),m.startupMessage&&(a.info("Disposing statusItem"),t==null||t.dispose(),d.window.showInformationMessage("clojure-lsp loaded!"))}0&&(module.exports={activate});
