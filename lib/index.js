var h=Object.defineProperty;var O=Object.getOwnPropertyDescriptor;var q=Object.getOwnPropertyNames;var H=Object.prototype.hasOwnProperty;var v=(t,e)=>{for(var o in e)h(t,o,{get:e[o],enumerable:!0})},D=(t,e,o,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of q(e))!H.call(t,r)&&r!==o&&h(t,r,{get:()=>e[r],enumerable:!(n=O(e,r))||n.enumerable});return t};var I=t=>D(h({},"__esModule",{value:!0}),t);var U={};v(U,{activate:()=>J});module.exports=I(U);var l=require("coc.nvim");var j=require("coc.nvim");var k=require("coc.nvim"),p=[{scheme:"file",language:"clojure"},{scheme:"jar",language:"clojure"},{scheme:"zipfile",language:"clojure"}],s;function P(){let t=k.workspace.getConfiguration("clojure"),e=t.inspect("keymaps"),o=t.inspect("executable"),n=t.inspect("enable"),r=t.inspect("executableArgs"),c=t.inspect("initializationOptions"),m=t.inspect("startupMessage");s={keymaps:{enable:t.get("keymaps.enable",e.defaultValue.enable),shortcut:t.get("keymaps.shortcut",e.defaultValue.shortcut)},enable:t.get("enable",n.defaultValue),executable:t.get("executable",o.defaultValue),executableArgs:t.get("executableArgs",r.defaultValue),initializationOptions:t.get("initialization-options",c.defaultValue),startupMessage:t.get("startup-message",m.defaultValue)}}function L(){let t={command:s.executable,args:s.executableArgs},e={run:t,debug:t},o={disabledFeatures:["signatureHelp"],documentSelector:p,initializationOptions:s.initializationOptions};return new j.LanguageClient("clojure","Clojure Language Client",e,o)}var i=require("coc.nvim");var C={};v(C,{commands:()=>S,default:()=>z});var S=[{command:"add-import-to-namespace",description:"Add specific require form to current namespace declaration",prompt:"Library name?",shortcut:"ai"},{command:"add-missing-import",description:"Add Java import for symbol under cursor to current namespace declaration"},{command:"add-missing-libspec",description:"Add require form for symbol under cursor to current namespace declaration",shortcut:"am"},{command:"add-require-suggestion",description:"Add suggested require to ns form",shortcut:"as"},{aliases:["change-coll"],choices:["list","vector","map","set"],command:"change-collection",description:"Choose new type of collection",prompt:"New coll type"},{command:"clean-ns",description:"Sort and remove unused required libraries in namespace declaration",shortcut:"cn"},{command:"create-function",description:"Create a function from the current form",shortcut:"fe"},{command:"create-test",description:"Creates a test somewhere, who knows",shortcut:"ct"},{command:"cursor-info",description:"Show debugging information for the symbol at cursor"},{command:"cycle-coll",description:"Cycle the kind of collection: list -> map -> vector -> set -> list",shortcut:"cc"},{command:"cycle-privacy",description:"Cycle the privacy of current function definition",shortcut:"cp"},{command:"demote-fn",description:"Demote fn to #()",shortcut:"dm"},{command:"docs",description:"Read the docs for a given symbol (in given namespace)"},{aliases:["move-coll-entry-up"],command:"drag-backward",description:"Move coll entry backwards in collection (will move map entries)",shortcut:"db"},{aliases:["move-coll-entry-down"],command:"drag-forward",description:"Move coll entry forwards in collection (will move map entries)",shortcut:"df"},{command:"expand-let",description:"Move current let form up a level",shortcut:"el"},{command:"extract-function",description:"Move current form into new top-level function",prompt:"Function name?",shortcut:"ef"},{command:"inline-symbol",description:"Replace all instances of symbol with symbol definition",shortcut:"is"},{command:"introduce-let",description:"Move current form to let-bound variable",prompt:"Bind to?",shortcut:"il"},{command:"move-coll-entry-down",description:"Move the current element (or pair) down within the collection"},{command:"move-coll-entry-up",description:"Move the current element (or pair) up within the collection"},{command:"move-form",description:"Move form under cursor to specified file",prompt:"Which file?",shortcut:"mf"},{command:"move-to-let",description:"Move current form into surrounding let block",prompt:"Bind to?",shortcut:"ml"},{command:"promote-fn",description:"Promote #() to fn, or fn to defn",shortcut:"pf"},{command:"resolve-macro-as",description:"Add entry to .clj-kondo/config.edn to resolve macro as another macro",shortcut:"ma"},{command:"server-info",description:"Show server configuration information"},{command:"sort-map",description:"Sort entries within current map",shortcut:"sm"},{command:"suppress-diagnostic",description:"Add a :clj-kondo/ignore to suppress linting current line",prompt:"Lint to ignore?"},{command:"thread-first",description:"Replace current form with thread-first expession",shortcut:"th"},{command:"thread-first-all",description:"Replace current and all nested forms with thread-first form",shortcut:"tf"},{command:"thread-last",description:"Replace current form with thread-last expession",shortcut:"tt"},{command:"thread-last-all",description:"Replace current and all nested forms with thread-last form",shortcut:"tl"},{command:"unwind-all",description:"Replace entire current threaded form with nested form",shortcut:"ua"},{command:"unwind-thread",description:"Replace first two forms in current threaded form with nested form",shortcut:"uw"}],z={commands:S};var a;function $(t){a=t.logger}async function w(t,e=""){return(await i.window.requestInput(t,e)).trim()}async function V(t){let e=await w("Var name?"),o=await w("Namespace?","clojure.core");if(e&&o){let n=await t.sendRequest("clojure/clojuredocs/raw",{symName:e,symNs:o}).catch(r=>{i.window.showErrorMessage(r)});n&&await i.window.showDialog({title:`${n.ns}/${n.name}`,content:n.doc})}}async function E(){let{line:t,character:e}=await i.window.getCursorPosition();return[(await i.workspace.document).uri,t,e]}var B=[{command:"docs",fn:V},{command:"cursor-info",fn:async t=>{let[e,o,n]=await E();return t.sendRequest("clojure/cursorInfo/log",{textDocument:{uri:e},position:{line:o,character:n}}).catch(r=>{i.window.showErrorMessage(r)})}},{command:"server-info",fn:async t=>t.sendRequest("clojure/serverInfo/log").catch(e=>{i.window.showErrorMessage(e)})}],R=(()=>{let{commands:t}=C,e=new Map;return t.concat(B).forEach(o=>{let n=o.command;e.has(n)||e.set(n,{command:n});for(let[r,c]of Object.entries(o))e.get(n)[r]||(e.get(n)[r]=c)}),[...e.values()]})();async function b(t,{command:e},o=[]){let n=await E();return t.sendRequest("workspace/executeCommand",{command:e,arguments:n.concat(o)}).catch(r=>{i.window.showErrorMessage(r)})}async function K(t,e){let o=await i.window.showMenuPicker(e,{title:t});if(o!==-1)return e[o]}async function N(t,e){let{title:o,choices:n}=e,r=await K(o,n);return b(t,e,[r])}async function T(t,e){let{title:o}=e,n=await w(o);if(n)return b(t,e,[n])}function F(t,e,o){let{command:n,fn:r,title:c,choices:m,aliases:d}=o,u=`lsp-clojure-${n}`,y=async()=>{if(m&&!i.workspace.env.dialog){a.info(`Workspace doesn't allow dialogs, cancelling command ${u}`);return}else if(r){let{fn:f}=o;return a.debug(`Executing 'fn' command ${u}`),f(e)}else m?(a.debug(`Executing 'choices' command ${u}`),await N(e,o)):c?(a.debug(`Executing 'prompt' command ${u}`),await T(e,o)):(a.debug(`Executing 'position' command ${u}`),await b(e,o))};a.debug(`Registering command ${u}`),t.subscriptions.push(i.commands.registerCommand(u,y)),d&&d.forEach(f=>{let x=`lsp-clojure-${f}`;a.debug(`Registering command ${x} as alias of ${u}`),t.subscriptions.push(i.commands.registerCommand(x,y))})}function W(t,e){let{command:o,shortcut:n}=e,r=`lsp-clojure-${o}`,{keymaps:c}=s,m=`${c.shortcut}${n}`;try{a.debug(`Creating keymap '${m}' for command '${r}'`),i.workspace.nvim.command(`nnoremap <silent> ${m} :call CocActionAsync('runCommand', '${r}')<CR>`,!0),t.subscriptions.push(i.Disposable.create(()=>{i.workspace.nvim.command(`nunmap ${m}`,!0)}))}catch(d){a.error(`Can't create keymapping ${m} for command ${o}`,d)}}function A(t,e){for(let o of R)F(t,e,o);if(s.keymaps.enable)for(let o of R.filter(n=>n.shortcut))W(t,o)}var g=class{constructor(e){this.client=e}async provideSignatureHelp(e,o,n,r){return this.client.sendRequest("textDocument/signatureHelp",{textDocument:{uri:e.uri},position:o,context:r},n).catch(c=>this.client.handleFailedRequest({method:"textDocument/signatureHelp"},n,c,null))}};async function J(t){if($(t),a.warn("inside coc-clojure"),P(),!s.enable)return;let e;s.startupMessage&&(a.info("Showing statusItem"),e=l.window.createStatusBarItem(void 0,{progress:!0}),e.text="Loading clojure-lsp",e.show()),a.info("Creating client");let o=L();t.subscriptions.push(l.services.registLanguageClient(o)),t.subscriptions.push(l.languages.registerSignatureHelpProvider(p,new g(o),["("," "])),A(t,o),await o.onReady(),s.startupMessage&&(a.info("Disposing statusItem"),e==null||e.dispose(),l.window.showInformationMessage("clojure-lsp loaded!"))}0&&(module.exports={activate});
